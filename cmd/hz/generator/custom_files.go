/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generator

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"text/template"

	"github.com/cloudwego/hertz/cmd/hz/util"
	"github.com/cloudwego/hertz/cmd/hz/util/logs"
)

type FilePathRenderInfo struct {
	MasterIDLName  string // master IDL name
	GenPackage     string // master IDL generate code package
	HandlerDir     string // handler generate dir
	ModelDir       string // model generate dir
	RouterDir      string // router generate dir
	ProjectDir     string // projectDir
	GoModule       string // go module
	ServiceName    string // service name, changed as services are traversed
	MethodName     string // method name, changed as methods are traversed
	HandlerGenPath string // "api.gen_path" value
}

type IDLPackageRenderInfo struct {
	FilePathRenderInfo
	ServiceInfos *HttpPackage
}

type CustomizedFileForMethod struct {
	*HttpMethod
	FilePath    string
	FilePackage string
}

type CustomizedFileForService struct {
	*Service
	FilePath    string
	FilePackage string
}

type CustomizedFileForIDL struct {
	*IDLPackageRenderInfo
	FilePath    string
	FilePackage string
}

// todo: 1. how to import other file, if the other file name is a template
//       2. how to update file when it's import changed
//       3. how to optimize "append update logic" for a file

func (pkgGen *HttpPackageGenerator) genCustomizedFile(pkg *HttpPackage) error {
	filePathRenderInfo := FilePathRenderInfo{
		MasterIDLName: pkg.IdlName,
		GenPackage:    pkg.Package,
		HandlerDir:    pkgGen.HandlerDir,
		ModelDir:      pkgGen.ModelDir,
		RouterDir:     pkgGen.RouterDir,
		ProjectDir:    pkgGen.OutputDir,
		GoModule:      pkgGen.ProjPackage,
		// methodName & serviceName will change as traverse
	}

	idlPackageRenderInfo := IDLPackageRenderInfo{
		FilePathRenderInfo: filePathRenderInfo,
		ServiceInfos:       pkg,
	}

	for _, tplInfo := range pkgGen.tplsInfo {
		// the default template has been automatically generated by the tool, so skip
		if tplInfo.Default {
			continue
		}

		// loop generate file
		if tplInfo.LoopService || tplInfo.LoopMethod {
			loopMethod := tplInfo.LoopMethod
			loopService := tplInfo.LoopService
			if loopService && !loopMethod { // only loop service
				for _, service := range idlPackageRenderInfo.ServiceInfos.Services {
					filePathRenderInfo.ServiceName = service.Name
					err := pkgGen.genLoopService(tplInfo, filePathRenderInfo, service)
					if err != nil {
						return err
					}
				}
			} else { // loop service & method, because if loop method, the service must be looped
				for _, service := range idlPackageRenderInfo.ServiceInfos.Services {
					for _, method := range service.Methods {
						filePathRenderInfo.ServiceName = service.Name
						filePathRenderInfo.MethodName = method.Name
						filePathRenderInfo.HandlerGenPath = method.OutputDir
						err := pkgGen.genLoopMethod(tplInfo, filePathRenderInfo, method)
						if err != nil {
							return err
						}
					}
				}
			}
		} else { // generate customized file single
			err := pkgGen.genSingleCustomizedFile(tplInfo, filePathRenderInfo, idlPackageRenderInfo)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func renderFilePath(tplInfo *Template, filePathRenderInfo FilePathRenderInfo) (string, error) {
	tpl, err := template.New(tplInfo.Path).Funcs(funcMap).Parse(tplInfo.Path)
	if err != nil {
		return "", fmt.Errorf("parse file path template(%s) failed, err: %v", tplInfo.Path, err)
	}
	filePath := bytes.NewBuffer(nil)
	err = tpl.Execute(filePath, filePathRenderInfo)
	if err != nil {
		return "", fmt.Errorf("render file path template(%s) failed, err: %v", tplInfo.Path, err)
	}

	return filePath.String(), nil
}

func renderAppendContent(tplInfo *Template, renderInfo interface{}) (string, error) {
	tpl, err := template.New(tplInfo.Path).Parse(tplInfo.AppendContent)
	if err != nil {
		return "", fmt.Errorf("parse append content template(%s) failed, err: %v", tplInfo.Path, err)
	}
	appendContent := bytes.NewBuffer(nil)
	err = tpl.Execute(appendContent, renderInfo)
	if err != nil {
		return "", fmt.Errorf("render append content template(%s) failed, err: %v", tplInfo.Path, err)
	}

	return appendContent.String(), nil
}

func getAppendFile(tplInfo *Template, renderInfo interface{}, fileContent []byte) ([]byte, error) {
	appendContent, err := renderAppendContent(tplInfo, renderInfo)
	if err != nil {
		return []byte(""), err
	}
	buf := bytes.NewBuffer(nil)
	_, err = buf.Write(fileContent)
	if err != nil {
		return []byte(""), fmt.Errorf("write file(%s) failed, err: %v", tplInfo.Path, err)
	}
	_, err = buf.WriteString(appendContent)
	if err != nil {
		return []byte(""), fmt.Errorf("append file(%s) failed, err: %v", tplInfo.Path, err)
	}

	return buf.Bytes(), nil
}

func (pkgGen *HttpPackageGenerator) genLoopService(tplInfo *Template, filePathRenderInfo FilePathRenderInfo, service *Service) error {
	filePath, err := renderFilePath(tplInfo, filePathRenderInfo)
	if err != nil {
		return err
	}
	// determine if a custom file exists
	exist, err := util.PathExist(filePath)
	if err != nil {
		return fmt.Errorf("judge file(%s) exists failed, err: %v", filePath, err)
	}
	if !exist { // create file
		data := CustomizedFileForService{
			Service:     service,
			FilePath:    filePath,
			FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
		}
		err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
		if err != nil {
			return err
		}
	} else { // update file based on update behavior, use 'switch' statements to make logic clearer
		switch tplInfo.UpdateBehavior {
		case Unchanged:
			// do nothing
			logs.Infof("do not update file '%s', because the update behavior is 'Unchanged'", filePath)
		case Regenerate:
			// re-generate
			logs.Infof("re-generate file '%s', because the update behavior is 'Regenerate'", filePath)
			data := CustomizedFileForService{
				Service:     service,
				FilePath:    filePath,
				FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
			}
			err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
			if err != nil {
				return err
			}
		case Append: // todo: append logic need to be optimized for method
			fileContent, err := ioutil.ReadFile(filePath)
			if err != nil {
				return err
			}
			if tplInfo.AppendKey == "method" {
				for _, method := range service.Methods {
					if bytes.Contains(fileContent, []byte(method.Name)) {
						continue
					}
					data := CustomizedFileForMethod{
						HttpMethod:  method,
						FilePath:    filePath,
						FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
					}
					file, err := getAppendFile(tplInfo, data, fileContent)
					if err != nil {
						return err
					}
					logs.Infof("append content for file '%s', because the update behavior is 'Append' and appendKey is 'method'", filePath)
					pkgGen.files = append(pkgGen.files, File{filePath, string(file), false, ""})
				}
			} else {
				logs.Warnf("Loop 'service' field for '%s' only append content by appendKey for 'method', so cannot append content", filePath)
			}

		default:
			// do nothing
			logs.Warnf("unknown update behavior, do nothing")
		}
	}
	return nil
}

func (pkgGen *HttpPackageGenerator) genLoopMethod(tplInfo *Template, filePathRenderInfo FilePathRenderInfo, method *HttpMethod) error {
	filePath, err := renderFilePath(tplInfo, filePathRenderInfo)
	if err != nil {
		return err
	}
	// determine if a custom file exists
	exist, err := util.PathExist(filePath)
	if err != nil {
		return fmt.Errorf("judge file(%s) exists failed, err: %v", filePath, err)
	}

	if !exist { // create file
		data := CustomizedFileForMethod{
			HttpMethod:  method,
			FilePath:    filePath,
			FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
		}
		err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
		if err != nil {
			return err
		}
	} else { // update file based on update behavior, use 'switch' statements to make logic clearer
		switch tplInfo.UpdateBehavior {
		case Unchanged:
			// do nothing
			logs.Infof("do not update file '%s', because the update behavior is 'Unchanged'", filePath)
		case Regenerate:
			// re-generate
			logs.Infof("re-generate file '%s', because the update behavior is 'Regenerate'", filePath)
			data := CustomizedFileForMethod{
				HttpMethod:  method,
				FilePath:    filePath,
				FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
			}
			err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
			if err != nil {
				return err
			}
		case Append:
			// for loop method, no need to append something; so do nothing
			logs.Warnf("do not append content for file '%s', because the update behavior is 'Append' and loop 'method' have no need to append content", filePath)
		default:
			// do nothing
			logs.Warnf("unknown update behavior, do nothing")
		}
	}

	return nil
}

func (pkgGen *HttpPackageGenerator) genSingleCustomizedFile(tplInfo *Template, filePathRenderInfo FilePathRenderInfo, idlPackageRenderInfo IDLPackageRenderInfo) error {
	// generate file single
	filePath, err := renderFilePath(tplInfo, filePathRenderInfo)
	if err != nil {
		return err
	}
	// determine if a custom file exists
	exist, err := util.PathExist(filePath)
	if err != nil {
		return fmt.Errorf("judge file(%s) exists failed, err: %v", filePath, err)
	}

	if !exist { // create file
		data := CustomizedFileForIDL{
			IDLPackageRenderInfo: &idlPackageRenderInfo,
			FilePath:             filePath,
			FilePackage:          util.SplitPackage(filepath.Dir(filePath), ""),
		}
		err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
		if err != nil {
			return err
		}
	} else { // update file based on update behavior, use 'switch' statements to make logic clearer
		switch tplInfo.UpdateBehavior {
		case Unchanged:
			// do nothing
			logs.Infof("do not update file '%s', because the update behavior is 'Unchanged'", filePath)
		case Regenerate:
			// re-generate
			logs.Infof("re-generate file '%s', because the update behavior is 'Regenerate'", filePath)
			data := CustomizedFileForIDL{
				IDLPackageRenderInfo: &idlPackageRenderInfo,
				FilePath:             filePath,
				FilePackage:          util.SplitPackage(filepath.Dir(filePath), ""),
			}
			err := pkgGen.TemplateGenerator.Generate(data, tplInfo.Path, filePath, false)
			if err != nil {
				return err
			}
		case Append: // todo: append logic need to be optimized for single file
			fileContent, err := ioutil.ReadFile(filePath)
			if err != nil {
				return err
			}
			if tplInfo.AppendKey == "method" {
				for _, service := range idlPackageRenderInfo.ServiceInfos.Services {
					for _, method := range service.Methods {
						if bytes.Contains(fileContent, []byte(method.Name)) {
							continue
						}
						data := CustomizedFileForMethod{
							HttpMethod:  method,
							FilePath:    filePath,
							FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
						}
						file, err := getAppendFile(tplInfo, data, fileContent)
						if err != nil {
							return err
						}
						pkgGen.files = append(pkgGen.files, File{filePath, string(file), false, ""})
					}
				}
			} else if tplInfo.AppendKey == "service" {
				for _, service := range idlPackageRenderInfo.ServiceInfos.Services {
					if bytes.Contains(fileContent, []byte(service.Name)) {
						continue
					}
					data := CustomizedFileForService{
						Service:     service,
						FilePath:    filePath,
						FilePackage: util.SplitPackage(filepath.Dir(filePath), ""),
					}
					file, err := getAppendFile(tplInfo, data, fileContent)
					if err != nil {
						return err
					}
					pkgGen.files = append(pkgGen.files, File{filePath, string(file), false, ""})
				}
			} else { // add append content to the file directly
				data := CustomizedFileForIDL{
					IDLPackageRenderInfo: &idlPackageRenderInfo,
					FilePath:             filePath,
					FilePackage:          util.SplitPackage(filepath.Dir(filePath), ""),
				}
				file, err := getAppendFile(tplInfo, data, fileContent)
				if err != nil {
					return err
				}
				pkgGen.files = append(pkgGen.files, File{filePath, string(file), false, ""})
			}
		default:
			// do nothing
			logs.Warnf("unknown update behavior, do nothing")
		}
	}

	return nil
}
